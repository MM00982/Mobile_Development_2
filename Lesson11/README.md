# Практическая работа №11

## Глава 1. Модификация слоя App (MVVM в MovieProject)

В рамках данной главы была произведена модернизация архитектуры учебного приложения «MovieProject». 
Исходная реализация подразумевала прямое взаимодействие Activity с UseCase-ами и Репозиторием, что 
нарушало принципы разделения ответственности и создавало проблемы при повороте экрана (потеря данных).
Для решения этих проблем был внедрен архитектурный паттерн MVVM (Model-View-ViewModel).
Реализация ViewModel:
Создан класс MainViewModel, который наследуется от androidx.lifecycle.ViewModel. Он выступает хранилищем 
состояния экрана. Взаимодействие с UI осуществляется через паттерн Observer с использованием MutableLiveData. 
Логика сохранения и получения любимого фильма перенесена из Activity в методы saveMovie() и getMovie() внутри 
ViewModel. Теперь Activity не знает о существовании UseCase, она лишь подписывается на изменения данных.

<img width="2560" height="1533" alt="image_2025-12-19_23-44-36" src="https://github.com/user-attachments/assets/dd0bb9fa-517f-4be9-9a05-c29f60c52574" />

Внедрение зависимостей (ViewModelFactory):
Так как для работы репозитория MovieRepositoryImpl требуется контекст (для SharedPreferences), невозможно 
использовать стандартный конструктор ViewModel по умолчанию. Был реализован класс ViewModelFactory, реализующий 
интерфейс ViewModelProvider.Factory. Фабрика берет на себя ответственность за инициализацию слоя Data (хранилища 
и репозитория) и передачу готового репозитория в конструктор MainViewModel.

<img width="2560" height="1534" alt="image_2025-12-19_23-45-03" src="https://github.com/user-attachments/assets/200afdf5-e274-4b97-ad30-5de6ba9b46dd" />

Модификация Activity:
Код MainActivity был очищен от бизнес-логики. Теперь Activity выполняет только роль View: инициализирует 
ViewModel через фабрику и подписывается на LiveData. При изменении данных во ViewModel, Activity автоматически обновляет текстовые поля на экране.

<img width="2560" height="1541" alt="image_2025-12-19_23-45-37" src="https://github.com/user-attachments/assets/de490296-afd7-4b22-8c94-73268668b8f1" />

---

## Глава 2. Контрольное задание (Travel Weather)

В этой части выполнена рефакторинг основного проекта «Travel Weather» для соответствия требованиям задания:
Взаимодействие Activity со слоем Domain должно осуществляться строго через ViewModel.
Обновление интерфейса должно происходить реактивно через LiveData.
Архитектура ViewModel:
Были созданы два ключевых класса: MainViewModel (для списка городов и поиска) и 
WeatherViewModel (для отображения прогноза). Вся работа с потоками (Thread, ExecutorService) 
и вызовы UseCase (GetFavorites, GetForecastByCity и др.) перенесены внутрь этих ViewModel.
Для управления зависимостями (БД Room, Retrofit, VoiceRepository) реализована единая ViewModelFactory, 
которая распределяет нужные репозитории по соответствующим ViewModel.

<img width="2560" height="1534" alt="image_2025-12-19_23-48-23" src="https://github.com/user-attachments/assets/c5482b49-1982-447f-8dc1-d81c771f8441" />

Главный экран (MainViewModel):
MainViewModel управляет списком избранных городов. Загрузка данных из БД происходит асинхронно, 
результат передается в favoritesLiveData. Также здесь обрабатывается результат голосового ввода: 
после распознавания аудиобайтов результат отправляется в Activity через LiveData, инициируя переход к прогнозу.

<img width="2560" height="1538" alt="image_2025-12-19_23-48-36" src="https://github.com/user-attachments/assets/867e6545-703d-491d-80dc-396e96fe8dd2" />

Экран погоды (WeatherViewModel):
В WeatherViewModel реализована логика загрузки текущей погоды и прогноза на 5 дней. Activity 
подписывается на currentWeather и forecast. Также через LiveData реализовано управление состоянием 
кнопки «Избранное»: ViewModel проверяет наличие города в БД и уведомляет UI, нужно ли отображать кнопку 
«Добавить» или «Удалить». Прямые вызовы методов UI из фоновых потоков были полностью устранены.

<img width="2560" height="1539" alt="image_2025-12-19_23-49-28" src="https://github.com/user-attachments/assets/dc687b17-85cc-425a-9b9b-556ee9626027" />

---

## Вывод

В ходе работы была успешно внедрена архитектура MVVM в оба проекта. Это позволило:
* Отделить логику отображения от бизнес-логики.
* Решить проблему сохранения состояния при конфигурационных изменениях (поворот экрана).
* Сделать код более чистым и тестируемым за счет использования ViewModelFactory и LiveData.
* В проекте Travel Weather полностью устранены прямые обращения Activity к базе данных и сети, что соответствует принципам Clean Architecture.


---

**Выполнил**: Мусин М.Р.  
**Группа**: БСБО-09-22
